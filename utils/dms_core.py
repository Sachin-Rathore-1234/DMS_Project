# -*- coding: utf-8 -*-
"""dms_core.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12R3BEyaaTm0ZGb-LESQJV0Mhose7yKQ3
"""

import cv2
import numpy as np
import tensorflow as tf
from ultralytics import YOLO
import mediapipe as mp
from mediapipe.tasks import python as mp_tasks
from mediapipe.tasks.python import vision as mp_vision

# ================= LOAD MODELS =================
IMG_SIZE = (224, 224)

eye_model = tf.keras.models.load_model("model/eye_state_cnn.h5")
yolo_model = YOLO("yolov8n.pt")

BaseOptions = mp_tasks.BaseOptions
FaceLandmarker = mp_vision.FaceLandmarker
FaceLandmarkerOptions = mp_vision.FaceLandmarkerOptions
RunningMode = mp_vision.RunningMode

landmarker = FaceLandmarker.create_from_options(
    FaceLandmarkerOptions(
        base_options=BaseOptions(model_asset_path="face_landmarker.task"),
        running_mode=RunningMode.IMAGE,
        num_faces=1
    )
)

LEFT_EYE_IDX  = [33, 160, 158, 133, 153, 144]
RIGHT_EYE_IDX = [263, 387, 385, 362, 380, 373]

# ================= UTILITY FUNCTIONS =================
def compute_ear(landmarks, eye_indices, w, h):
    pts = []
    for idx in eye_indices:
        pts.append([
            landmarks[idx].x * w,
            landmarks[idx].y * h
        ])
    pts = np.array(pts)

    A = np.linalg.norm(pts[1] - pts[5])
    B = np.linalg.norm(pts[2] - pts[4])
    C = np.linalg.norm(pts[0] - pts[3])

    if C == 0:
        return 0.0
    return (A + B) / (2.0 * C)


def predict_eye_prob(eye_region_bgr):
    if eye_region_bgr is None or eye_region_bgr.size == 0:
        return 0.5

    eye_rgb = cv2.cvtColor(eye_region_bgr, cv2.COLOR_BGR2RGB)
    eye_resized = cv2.resize(eye_rgb, IMG_SIZE)
    eye_norm = eye_resized.astype("float32") / 255.0
    eye_input = np.expand_dims(eye_norm, axis=0)

    return float(eye_model.predict(eye_input, verbose=0)[0][0])


def process_frame(
    frame,
    closed_frames,
    fps,
    ear_threshold=0.23,
    prob_threshold=0.30
):
    """
    Processes one frame and returns:
    processed_frame, updated_closed_frames, drowsy_flag
    """

    drowsy = False
    limit = int(fps * 2)

    results = yolo_model(frame, verbose=False)

    for box in results[0].boxes:
        if int(box.cls[0]) == 0:  # person
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            x1, y1 = max(0, x1), max(0, y1)
            x2, y2 = min(frame.shape[1], x2), min(frame.shape[0], y2)

            roi = frame[y1:y2, x1:x2]
            if roi.size == 0:
                continue

            roi_rgb = cv2.cvtColor(roi, cv2.COLOR_BGR2RGB)
            mp_image = mp.Image(
                image_format=mp.ImageFormat.SRGB,
                data=roi_rgb
            )

            result = landmarker.detect(mp_image)

            if result.face_landmarks:
                lm = result.face_landmarks[0]
                h, w = roi.shape[:2]

                ear = (
                    compute_ear(lm, LEFT_EYE_IDX, w, h) +
                    compute_ear(lm, RIGHT_EYE_IDX, w, h)
                ) / 2.0

                eye_region = roi[0:h//2, :]
                prob_open = predict_eye_prob(eye_region)

                if ear < ear_threshold and prob_open < prob_threshold:
                    closed_frames += 1
                    state = "CLOSED"
                else:
                    closed_frames = 0
                    state = "OPEN"

                cv2.rectangle(frame, (x1, y1), (x2, y2), (0,255,255), 2)
                cv2.putText(frame, f"{state}", (x1, y1-10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,255,0), 2)

                if closed_frames > limit:
                    drowsy = True
                    cv2.putText(frame, "DROWSY !!!",
                                (int(frame.shape[1]*0.25), int(frame.shape[0]*0.5)),
                                cv2.FONT_HERSHEY_SIMPLEX, 2,
                                (0,0,255), 5)

            break

    return frame, closed_frames, drowsy